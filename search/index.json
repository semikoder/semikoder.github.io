[{"content":"This project is based on: http://www-cs-students.stanford.edu/~amitp/game-programming/polygon-map-generation/\nCouple days ago, I came across this interesting article called \u0026ldquo;Polygonal Map Generation for Games\u0026rdquo;. At first glance, I wasn\u0026rsquo;t entirely interested, as I mostly generate my terrain using perlin noise. This is a much easier implementation - Unity\u0026rsquo;s Math library officially supports perlin noise, making it easier for Unity users to implement perlin noise based terrains. However, the maps generated by perlin noise aren\u0026rsquo;t entirely good for creating island maps. Sure, there is a workaround for it, but it\u0026rsquo;s always hard to get an island looking map just by using perlin noise. They often end up less realistic maps that look like a noise if seen from the top view. Otherwise, if the map has a fixed size in general, polygonal map generation would work much better. There will always be just one mountain where player can go on top of, unlike the noise function.\nA voronoi diagram has been calculated using csDelaunay library (https://github.com/PouletFrit/csDelaunay). When you pick random points and generate Voronoi polygons, the maps tend to look very irregular. These irregular polygons are definitely not what we want for a terrain. If maps were generated directly using the edges would look rough. This is where the Lloyd\u0026rsquo;s algorithm and relaxation comes in. Using multiple relaxation iterations, we can make the voronoi polygon map a lot more smoother and distribute the polygons evenly. Therefore, making the map look smoother.\nDuring the map data generation, the following information needs to be calculated: adjacent polygon (neighbor cells), edges, island. Using these information, elevation of the terrain as well as the biome can be calculated. Once the island coast has been generated, we can fill the selected island with land, others with water. Calculating the elevation is quite easy (compared to perlin noise), as I just took the distance of a cell from the coast and used that information for elevation. So the center cell of the whole island would have the highest elevation.\nFinally, the data goes through a so-called \u0026ldquo;Elevation Curve\u0026rdquo;, which lowers the lower part of the terrain further more, while making elevated terrains even more elevated. A flat curve (constant 1) would make a minimal difference between the lower part and the higher part of the terrain.\n\rElevation Curve\r\nOnce all the data has been generated, it was all about generating the mesh (with mesh colliders), translating the generated data to a texture then assigning the texture to the mesh. Except, I had to create the height map for the mesh separately (in float[,] variable), so that I could assign this variable to the terrain mesh directly.\nYou might notice that the generated map looks a little bit \u0026ldquo;pixelated\u0026rdquo;. This is because Unity has a limit on how many vertices one mesh object can have. It\u0026rsquo;s generally not a good practice have a lot of vertices on a single mesh. A workaround for this would be separating the terrain mesh into different parts (in this case, into 4 smaller mesh objects) and connecting them together. Similar to Minecraft\u0026rsquo;s implementation of chunks. This would also allow me to put multiple islands together. Terrain\u0026rsquo;s texture size in the pictures below have 200x200. Terrain textures bigger than this would exceed the maximum allowed number of verticies on the mesh.\n\rGenerated Map\r \rGenerated Map2\r \rGenerated Map3\r\nI\u0026rsquo;m happy with the end result, but its performance is not as good as if I were to generate using perlin noise. If I were to make a full map using this method of terrain generation (multiple islands), it would definitely be much harder for computers. To be fair, all of the calculations are done on a single thread, meaning the calculations that I\u0026rsquo;ve performed was only done on a single core of a processor. Multi-threaded calculations would definitely be a lot better for the performance.\n","date":"2021-11-19T00:00:00Z","image":"https://semikoder.github.io/p/polygonal-terrain-generation/polygonal_terrain_generation_1_hucee10becb4d1cd630c80bc244da2cc2e_236258_120x120_fill_box_smart1_3.png","permalink":"https://semikoder.github.io/p/polygonal-terrain-generation/","title":"Polygonal Terrain Generation"},{"content":"WIP\n","date":"2021-10-11T00:00:00Z","permalink":"https://semikoder.github.io/p/mesh-simplification-using-quadric-error-metrics/","title":"Mesh Simplification using Quadric Error Metrics"},{"content":"For only 5 days, I worked on an entry for \u0026ldquo;Dani\u0026rsquo;s basement Jam\u0026rdquo; (https://itch.io/jam/danis-discord-server-jam). Total 93 entries were made to this game jam and 711 ratings in total. This game jam is hosted by a YouTuber called Dani. As he didn\u0026rsquo;t publicly announce this game jam on his YouTube channel, there weren\u0026rsquo;t a lot of participants. I used Unity game engine to make Scattered. For pixel arts and animations, I used Piskel. I\u0026rsquo;m really happy about how the art style of the game turned out. Reading the comments that were made to my entry, it seems like everyone liked the art style too.\nI actually placed #2 overall in this game jam. In fact, #1 in art and sound/music. I didn\u0026rsquo;t actually make the music (and I did state this in the submission), but I did make my own sound effects. I recorded them using my mic and edited them on Audacity. Sonud effects are made by either my mouth or playing around with different objects.\nThe following YouTube video explains how the submission went: \r\r","date":"2020-09-18T00:00:00Z","permalink":"https://semikoder.github.io/p/scattered/","title":"Scattered"},{"content":"For the past two weeks, I worked on an entry for \u0026ldquo;Brackeys Game Jam 2020.2\u0026rdquo; (https://itch.io/jam/brackeys-4). This is a bigger game jam that\u0026rsquo;s hosted by a YouTuber named \u0026ldquo;Brackeys\u0026rdquo;. I used Unity game engine to make a game in two weeks based on an announced theme, \u0026ldquo;Rewind\u0026rdquo;. The following YouTube video explains how the submission went: \r\r","date":"2020-08-13T00:00:00Z","permalink":"https://semikoder.github.io/p/replay/","title":"Replay"},{"content":"For the past two weeks, I worked on an entry for \u0026ldquo;I Can\u0026rsquo;t Draw But Want To Make A Game\u0026rdquo; game jam. This game jam mainly targets people who want to make a game and submit it to the game jam, but don\u0026rsquo;t have good ability to draw. I decided to join this game jam, as I myself isn\u0026rsquo;t a good artist and I just found this game jam to be interesting. Game jam is basically a competition where you have to make a game in limited time based on a theme that\u0026rsquo;s given by the moderator. Here\u0026rsquo;s how it went for me (youtube video): \r\rThis is my itch.io page (entry): https://foorfootstudios.itch.io/protect-the-sandcastle\n","date":"2020-06-10T00:00:00Z","permalink":"https://semikoder.github.io/p/protect-the-sandcastle/","title":"Protect The Sandcastle"},{"content":"Progression is an Android game made with Unity that I recently released on Google Play store (that is still downloadable on Google play, link to the download at the bottom). It didn\u0026rsquo;t take me a long time for me to develop this game as the whole system was very easy to implement. The main point of this development was to make a simple game in a short duration just so I can get more motivated and get the Unity development wheels rolling again, as I took a break after finishing Sketch Hero.\n\rMain menu\r\nProgression is a simple arcade shooter. There are a total of 75 waves (originally 50, but I got requested to make more levels, as they were too \u0026ldquo;easy\u0026rdquo; to complete), and the goal of the game is to defeat all the enemies that spawn in each wave and reach 75 waves. The difficulty of the wave progress as it gets higher and the player needs to destroy them all by progressing them. Kind of like an RPG game, except the options, are limited. The player can upgrade their character by an in-game shop which they can use with in-game money they earn by destroying enemies in the game. Another option for an upgrade is picking up \u0026ldquo;upgrade\u0026rdquo; items within the match. This gives the player a more significant upgrade, but this effect is gone once the player exits the match. It is near impossible for a player to complete the game in the first match. The whole concept was to grow their character throughout different matches and upgrade their character using the money they earn.\nI originally designed this game to be extremely difficult to complete. I had a hard time balancing each enemy\u0026rsquo;s ability in the match. I should plan out all the features of the game as well as the enemy\u0026rsquo;s stats before I make them. I didn\u0026rsquo;t genuinely spend a lot of time planning the game before I develop, unlike the other ones, because back then I thought the development process would only take 3 - 4 weeks (I finished all the core mechanics within 2 weeks, but the polishing and fixing bugs took longer).\nI used the object pooling system to spawn different enemies and sort of \u0026ldquo;recycle\u0026rdquo; them when they died. Because the platform I was targeting was Android, optimization was mandatory for this project as well. I couldn\u0026rsquo;t just instantiate (spawn) a new object whenever the enemy spawns or destroy an enemy object completely. The code that gets ran in the background when initialized, destroyed would degrade the performance too much. I faced a problem, however. Because I was using an object pooling system, there had to be enough enemies spawned beforehand. This means that, if I want to spawn 30 A enemies in a match, I need to have 30 A enemies in the beginning of the game. This might sound a bit silly and obvious, but here\u0026rsquo;s the problem: I didn\u0026rsquo;t want to fill the wave up with the same type of enemy. So I made different types of enemies (I used different shapes so like: square, hexagon, circle, etc.). Now let\u0026rsquo;s say I want to spawn 30 enemies in total, but I want to randomly select enemies between square and circle. Meaning some enemies from total enemies spawned are square while others are circle. Because this is all handled randomly there are a tiny odd that only square enemy can spawn. This means that I would need 30 square enemies in the pool to fill up the match with 30 square enemies (requested). This might not be that big of a problem, but what if I want to add more enemies in a wave and more variety of enemy types? I would need to spawn in so many enemies in so many different types beforehand and at some point, the object pooling system wouldn\u0026rsquo;t just work. One solution that I found was to check if the enemy is not available (\u0026ldquo;sold out\u0026rdquo;, there are no enemies left in object pool to spawn) and if not, spawn a different enemy. Unfortunately, I ended up not using this method, because the code was just getting too messy and I just didn\u0026rsquo;t want to touch it any further. I concluded with a dirty way of handling this which was just spawning a bunch of enemies beforehand and HOPING it wouldn\u0026rsquo;t result in such odd that enemy type won\u0026rsquo;t get \u0026ldquo;sold out\u0026rdquo;.\nI didn\u0026rsquo;t bother with the UI that much. UI could\u0026rsquo;ve improved by A LOT in multiple aspects\u0026hellip;\n\rUpgrade menu\r\nSomething that I enjoyed making during the development was boss fights. It was the first time for me to make bosses, so I wasn\u0026rsquo;t sure how I should start. Turned out to be easier and better than I thought/expected. Although, I wouldn\u0026rsquo;t say I\u0026rsquo;m 100% satisfied with the product. There are things that I want to improve/could\u0026rsquo;ve improved on.\n\rBossfight\r\nI also added ads (supported by Unity) for this game. I didn\u0026rsquo;t expect to make money from it at all (in fact, I didn\u0026rsquo;t \u0026ldquo;make\u0026rdquo; any. I got around 3 dollars USD by ads, but I couldn\u0026rsquo;t withdraw it since the withdrawal process is only allowed once you earn more than 100 dollars USD. That\u0026rsquo;s how Unity ad system works I guess\u0026hellip;) but I just wanted to try and see how it works. Turned out to be easier than I was expecting.\nI undoubtedly realized how important the whole planning procedure was throughout this project. Not only I could\u0026rsquo;ve avoided a lot of bugs that happened just because I wasn\u0026rsquo;t thinking about it enough (like the enemy spawning issue I addressed earlier in the post), but also saved a lot of time. This project might have finished under a month if I had done proper planning. I don\u0026rsquo;t want to touch on this project any further just because I didn\u0026rsquo;t plan on working on it once I\u0026rsquo;m done. Not only that, due to the lacking planning I did, I just don\u0026rsquo;t want to go over it anymore.\nAs I mentioned, it only took around 3 - 4 months in total to create this game from scratch, all the way to polishing. Sure, the game could\u0026rsquo;ve been made in a shorter period, just because of how simple it is, but I was bothered by other more important priorities of my life when I was developing. This might sound like an excuse (which I\u0026rsquo;m not denying) but I could only work on the game for around 5 hours per week.\nBut to be honest, overall the game could\u0026rsquo;ve improved in a lot of different ways. I feel like I wasn\u0026rsquo;t giving my best for this project. I\u0026rsquo;m going to spend more time polishing and finishing the game better next time.\nHere are some gameplay screenshots:\n\rGameplay\r \rGameplay2\r \rGameplay3\r\nDownload Link: https://play.google.com/store/apps/details?id=com.FourFootGames.Progression\n","date":"2020-02-17T00:00:00Z","image":"https://semikoder.github.io/p/progression/Gameplay01_hu270ef3279ff744257fa739c92ad719f4_53800_120x120_fill_box_smart1_3.png","permalink":"https://semikoder.github.io/p/progression/","title":"Progression"},{"content":"\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;DISCONTINUED\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\nOne Room Survival is a game that I started making after I published Sketch Hero. After careful consideration, I decided to make a PC game. Possibly also port it to Android, if the impressions of the game are good. Something that I had to consider while planning the project was marketing. In the beginning, I also had no idea where to exactly publish my game. Steam, a huge game \u0026ldquo;store\u0026rdquo;, which is commonly used by most of the gamers, was not an option for me personally, as I couldn\u0026rsquo;t pay for the fee that\u0026rsquo;s required for me to publish the game on Steam. I came across gamejolt and itch.io. They\u0026rsquo;re both game stores that are less popular to gamers, but still very popular. Games on those websites are usually made by indie developers, as developers are allowed to publish their game for free without an additional fee. You can also sell/buy games here as well. I ended up with itch.io, just because it was a bit more user-friendly and a bit more popular among the gaming community. Sad part is that this projected ended and the game didn\u0026rsquo;t even see the light.\nOne Room Survival game is as the title suggests, you must survive in one room with limited resources. Player gets daily food supply with a little bit of water, but you can only get so much that you will soon starve to death. Player must find a way to escape the room and/or survive the longest possible. The rough story idea is that the player needs to dig a cave and make an escape path. Digging a cave/going mining reduces player\u0026rsquo;s health and makes him hungry/dehydrated quicker. Player needs to carefully decide when to go mining and how long he should mine. That was the whole concept of the game. The project wasn\u0026rsquo;t too big, it was planned with Trello and google docs and it was just generally good and well set up.\nI don\u0026rsquo;t have a lot of screenshots to show: 1. it\u0026rsquo;s one room survival game, you only interact in one room. 2. I stopped working on the game before making bigger progress.\nTwo things that I particularly wanted to focus on during the development were lighting/environment settings and UI. In my last couple 3D projects, such as Awaken Sentinel (3D multiplayer FPS game), I didn\u0026rsquo;t focus on the scene lighting and the mood of it rather focused on the post-processing effects and how the camera renders the scene. There\u0026rsquo;s a difference between how the camera renders (post-processing) the scene and how the scene looks like (lighting/environment setup). I consider how the scene looks far more important than how the camera renders now. Of course, adding post-processing effects does help the mood you want to go for, but I feel like it\u0026rsquo;s a bit more natural if you\u0026rsquo;re adjusting the whole scene lighting.\nI baked the lighting using the \u0026ldquo;Progressive GPU\u0026rdquo; option in Unity. I did not use real-time lighting at all. I thought real-time lighting would unnecessarily take performance when all the scene objects are stationary (you can only bake lighting if the models are not going to move during the game. real-time lighting is usually used for things like characters, so objects that move during the game). Baking lighting simply means making an image, that can be projected on the objects in the scene to simulate that there are things like shadows in the scene. I used fake shadows for the character. It is possible to mix baked and real-time lighting, but I liked the look of the fake shadows (just a \u0026ldquo;circle\u0026rdquo; on where the character is standing) more for this game. However, I did use real-time shadows for the objects that can be picked up by the player. This was the only solution, as baked shadows are always there, projected on the room, even the object is not visible to the camera. For the lights, I applied emissive material on the cylinder (light bulb). No directional/environmental lights were used. I would like to specifically point out that I baked ambient occlusion, as on my other projects, I\u0026rsquo;ve been using screen space ambient occlusion instead. Screen space ambient occlusion (SSAO) is a post-processing effect, which is used on the rendering camera to \u0026ldquo;simulate\u0026rdquo; the ambient occlusion of the environment. This is less realistic and very performance heavy as it needs to calculate where the proper shadow needs to be. In case you don\u0026rsquo;t know what ambient occlusion is, it\u0026rsquo;s a shadow/darker part that\u0026rsquo;s between two objects when they collide together\nHere\u0026rsquo;s how it turned out:\n\rGameplay\r\n\rSceneview\r\nCharacter model is missing. This is due to incompatibility. Unity updated itself so much that some file extensions are not readable/compatible. I\u0026rsquo;m writing this from the future.\nAs I mentioned, I also focused on UI this game. I didn\u0026rsquo;t spend a lot of time tinkering the whole Unity UI system or properly design UI on my other games, so I wanted to try something new for this project. It obviously didn\u0026rsquo;t turn out to be the best and I know I can improve a lot, but here\u0026rsquo;s how it is:\n\rGameplay2\r\nSomething that I\u0026rsquo;m proud of is the pickup system. Player can interact with the object in the room and pick them up if they want to. Player is also able to use them if they are usable.\n","date":"2019-09-18T00:00:00Z","image":"https://semikoder.github.io/p/one-room-survival/oneroomsurvival_hub38c463652888b1ca5a7643a7420d152_410020_120x120_fill_box_smart1_3.png","permalink":"https://semikoder.github.io/p/one-room-survival/","title":"One Room Survival"},{"content":"\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;DISCONTINUED\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\nFor the past 2 weeks, I\u0026rsquo;ve been working on a smartwatch project using my Arduino Pro Mini 3.3v (ATMEGA328P @ 8Mhz). My intention is my smartwatch will connect to my phone and receive all the useful information such as time, notification and messages. Because it uses the time from my mobile phone, it does not need a separate RTC (Real Time Clock), benefitting the size of the smartwatch. I also don\u0026rsquo;t have to replace the battery of RTC.\nFor the Bluetooth module, I used HM-10 clone which is a BLE(Bluetooth Low Energy) module. During the development process, I realized one unfortunate thing. My HM-10 clone ONLY supported BLE. Any legacy Bluetooth connection technology was unsupported. Therefore, I had to create an app just to connect to my device and send information. (I was going to make an app for my smartwatch anyway, but the process of developing an app was a bit harder since there weren\u0026rsquo;t a lot of tutorials on how to connect to a BLE device using Android Studio online.) There is a HM-10 firmware update, which would allow legacy Bluetooth technology, but because I have the clone HM-10, it didn\u0026rsquo;t work. Other than that, I used an 128x64 OLED display (SSD1306), vibrator (vibration motor), a push-button for executing simple task within the watch (turning the screen on when it\u0026rsquo;s in sleep to check time, etc.), a switch to power the device on, an apple watch 4 wrist band/case for the casing and 150mah 3.7v battery for powering the whole device.\nFor the case, I just purchased an Apple Watch (I\u0026rsquo;m not sure what series but the biggest one 140mm xD) case. I had to take the back off, though. My watch was too thick. I had to make my lid, which I did with some cheap fabric (which I got from a dollar store) and I wrapped it around with the electrical tape.\nI\u0026rsquo;ve already got the time working correctly as well as it notifies me when I receive a notification in my phone (although it doesn\u0026rsquo;t display from which app the notification was sent from, nor the details of the notification). Here\u0026rsquo;s a quick demo of my smartwatch: \r\r(yes I know, I changed google accounts several times xD I\u0026rsquo;m JCN) I\u0026rsquo;m still undone with my smartwatch and I\u0026rsquo;ll still improve the software and battery life as it doesn\u0026rsquo;t last long (according to my calculations, around half a week). I\u0026rsquo;m also planning a smartwatch v2, which would use ATTiny85, as the smartwatch I made turned out to be way too \u0026ldquo;fat\u0026rdquo;. Haha. But that won\u0026rsquo;t happen shortly.\nEDIT: Hey, future me here. This project is discontinued! I was facing a lot of issues during development. They could\u0026rsquo;ve been solved, but that caused me to buy new parts, because while I was putting everything back together after I made some micro-adjustments, I accidentally touched parts that I shouldn\u0026rsquo;t have and physically broke them. I realized I was spending way to much money on a smartwatch project. I was also busy with high school exams and so on and\u0026hellip; to be honest, I was just not motivated enough after that. However, I\u0026rsquo;m considering to bring this project back to life again! I\u0026rsquo;ll post an update when I decide.\n","date":"2019-03-25T00:00:00Z","permalink":"https://semikoder.github.io/p/arduino-smartwatch/","title":"Arduino Smartwatch"},{"content":" \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;DISCONTINUED\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\nSketch Hero is my first Unity Android game project that I published to Google Play store which I worked for around a year.\n\rMain menu\r\nI spent a lot of time developing this game and I\u0026rsquo;m really satisfied with how it turned out. I made this game to see how well I know about Unity. Sketch Hero is an endless runner, which means the player plays the game endlessly while trying to achieve the highest score possible. It\u0026rsquo;s a platformer, where player can interact with the map and needs to go as fast as possible while dodging all the dangerous obstacles. Kind of like temple run, except it\u0026rsquo;s 2D. Player can also draw lines which are colliders for the character inside the game. So basically, you draw and help the character to go as furthest possible.\nI first got the idea while I was just playing around with Unity game engine. I made a simple drawing system in Unity to learn about different components in Unity. Then, this idea suddenly came into my mind. That\u0026rsquo;s how Sketch Hero was born. The original name was Pocket Runner, but after noticing that this name is too common, I realized not a lot of people are going to find this game on Google Play (there were also an app called Pocket Runner on Google Play already. I didn\u0026rsquo;t want to use the same name for my game.). After a lot of thoughts, I ended up with the name: \u0026ldquo;Sketch Hero\u0026rdquo;.\nAlmost all of the graphics are downloaded from the internet. I BELIEVE they can be used without giving credit. I didn\u0026rsquo;t know/care licensing that much back then. I know for a fact that the assets (like characters) are mostly downloaded from kenney.nl (great website btw) and their asset is CC0, however.\nBecause this is an endless runner, I had to generate terrain procedurally. I didn\u0026rsquo;t want to make the game boring and have the same \u0026ldquo;pieces\u0026rdquo; of the map going (or even worse, same map) over and over again. The solution I used was perlin noise. It\u0026rsquo;s not entirely random noise. Each has some sort of relation to each other and this was just perfect. Because the terrain had to be smooth and not jump around (if this makes sense at all\u0026hellip; they coordinate of the terrain has to be smoothly interpolated between each x value). Now I could\u0026rsquo;ve also used pseudorandom number generator (the \u0026ldquo;normal\u0026rdquo; random number generator) and interpolated with linear interpolation method or something similar, but this would give me too much fluctuation that I can barely control. I first generated different \u0026ldquo;pieces\u0026rdquo; of the map (around 10 x tiles laid down together) using perlin noise. This procedure happened while loading the game, which means before the game starts. For the release version of Pocket Runner, I ended up generating 60 different pieces. I know it\u0026rsquo;s a bit too much, but I didn\u0026rsquo;t want to make the game feel repetitive at all. This was necessary, as generating the map real-time (noise calculations, placement, etc.) was taking up way too much performance on a mobile device. Although the high-end mobile device wasn\u0026rsquo;t bothered by this at all, I was also targeting lower-end smartphones, so optimization was mandatory. Once all the pieces are generated, the game randomly picks a generated piece from pieces array and lays it down in real-time. As the character moves further and further, new pieces gets picked randomly and placed down while the older pieces get disabled (performance reasons). Procedural terrain generation is the feature of the game that I\u0026rsquo;m most proud of. If I look at the code right now, there are still a lot of major changes that I can do to make it cleaner and more efficient. But if it works, hey it works :)\nI tried to make the UI simple yet can be interacted easily without much effort. I spent a lot of time making them, hopefully, they turned out to be good. I\u0026rsquo;m still bad at making them xD\nI also made a tutorial for this game (with animations too!), but I\u0026rsquo;m not sure how well this turned out, as some people still didn\u0026rsquo;t know how to \u0026ldquo;properly\u0026rdquo; play the game even after reading the whole tutorial. Some recommended me to do a tutorial within the game, interactively. Perhaps that\u0026rsquo;s something that I should consider in my next game.\n\rTutorial\r\nThe shop system is also something that I worked on for a long time. It also turned out to be better than I expected.\n\rShop\r\nI didn\u0026rsquo;t know how to make a proper settings menu, so this is what I did\u0026hellip;\n\rSettings\r\nI heard great feedback from the game, overall a very fun experience so I\u0026rsquo;m really happy about this project.\nHere are some screenshots of the game:\n\rGameplay\r \rGameplay2\r \rGameplay3\r \rGameplay4\r \rGameOver\r\n\r\r(I was NANO Engine back then.)\nEDIT: Hey, future me here. This project is discontinued! After hearing my game got taken down by Google for \u0026ldquo;violating Google policy\u0026rdquo; (I mean, I understand I used some assets from online, but they were all CC0 which means I was able to use them without giving credit whatsoever. Maybe I understood the licensing incorrectly, I didn\u0026rsquo;t bother too much with licensing back then. I was an inexperienced game developer.), I just didn\u0026rsquo;t want to work on it any further. Without knowing the exact reason why it was violated, I wasn\u0026rsquo;t motivated enough to polish the game, make adjustments and post it again on Google Play. I know I could email Google about the problem and ask what went wrong, but back then, I just wanted to move along.\n","date":"2018-10-13T00:00:00Z","image":"https://semikoder.github.io/p/project-sketch-hero/gameplay_hu8284bd1ddda761c43b534c649f0a9a7f_249100_120x120_fill_box_smart1_3.png","permalink":"https://semikoder.github.io/p/project-sketch-hero/","title":"Project Sketch Hero"},{"content":"\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;DISCONTINUED\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\nKeep in mind I\u0026rsquo;m writing this a year after I stopped making this game. I didn\u0026rsquo;t bother with portfolio or whatsoever back then.\nAwaken Sentinel is the first game that I started making seriously on Unity game engine. It\u0026rsquo;s a multiplier FPS with open-world aspects. I can\u0026rsquo;t provide any further information to the game, nor the story, as the whole project started just because I wanted to learn something and I didn\u0026rsquo;t plan on publishing at all/have the finished product. I worked on this game a bit more than a year. I was interested in FPS games back then, so I wanted to create my own FPS game. That\u0026rsquo;s literally how it started. I just wanted to make an FPS game. It took so long for me to make such small progress because I didn\u0026rsquo;t plan anything and I kept changing throughout the development. I changed the concept/theme multiple times. I was also very new to the whole game development. I didn\u0026rsquo;t know where to start/how to start/how to make a successful game. I first started making this game alone by myself, but later when I realized I needed some help I recruited several developers to work on the game with me. I especially needed assistance regarding modeling, animations and sound designs as I had no previous experiences with them. As I already mentioned, I was a newbie in game development when I started making this game. I had ambitious goals (this is something that every starter indie game developers have I believe. They try to replicate their favorite game.) on the game, Awaken Sentinel. Something I learned throughout this game development, which is also something that I will never forget is, never start with big ambitious goals when you\u0026rsquo;re just starting out. I realized this after attempting to create big games 2 - 3 times. It\u0026rsquo;s highly probable that you will lose your motivation quite shortly after. Start with something small, put your hands on the end product of yours. This will get you more motivation to create bigger projects and complete them. However, as I mentioned, Awaken Sentinel was like the first serious game that I was developing. I didn\u0026rsquo;t want to let go after developing for like a couple of months.\nAwaken Sentinel is formally known as Color Wars. The original idea was that different colored people would fight as a team together, but I ended up discarding this whole concept, as it could be offensive in a certain way.\nWARNING: Before you continue reading, please note that I was new to the whole game development industry. I didn\u0026rsquo;t know/care much about the copyright and whole licensing. Most of the assets (animations, models, but not scripts/code) that I used on this game are ripped off from another game or downloaded without giving proper credit. I didn\u0026rsquo;t bother that much at that point as I wanted to replace those models with the models that were created by my team back then.\nI only started taking a screenshot after around half a year later. Early screenshots are not available.\nFPS mechanics were quite easy for me to understand and implement within Unity. Not only there\u0026rsquo;s a lot of features and functions I could use directly, but there were also a lot of Unity tutorials / well-written documentation I could easily follow. Using those two resources, I managed to create a basic FPS shooter without any problem. Although, Unity was still one of the \u0026ldquo;newer\u0026rdquo; engines back then. FPS tutorials were not that in-depth, to say the least. Tutorials only covered the basics. Any more in-depth complicated functions had to be made purely by myself by looking at the documentation and trying it out.\nBecause this was FPS and I was super excited about the whole multiplayer thing back then, I wanted to integrate the multiplayer system to my game. I did make a successful functional multiplayer functionality using Photon networking (basically, an awesome multiplayer networking solution for different game engines, particularly Unity), but I quickly faced one problem. Resources. Multiplayer means, that there needs to be a host computer that hosts the whole multiplayer server so the clients can communicate with each other through the host. This means, that I would need to have the server of some sort running 24/7. No one wants to sacrifice their computer and host my game\u0026rsquo;s server 24/7. This means I had to buy a server (server is not free\u0026hellip;). It\u0026rsquo;s not a one-time purchase either. I had to pay around 10 dollars per month (this was the cheapest plan). But here\u0026rsquo;s the thing: is it worth it for me to spend 10 dollars per month on a server for a game that no one knows about and it\u0026rsquo;s not even released? I ended up not buying a server at all. This also contributed to the end of this game development.\n\rMultiplayerDemo\r (The character is t-posing because the animation synchronization was still in progress. I just noticed the character looks small\u0026hellip;)\nI also made a login system using \u0026ldquo;Database Control (Free)\u0026quot; which I downloaded through Unity\u0026rsquo;s asset store. It was a free solution for me to create a login database system. This, however, does not have any encryption to the database whatsoever, meaning that there\u0026rsquo;s a high risk of it getting hacked/leaked to the public. I wasn\u0026rsquo;t concerned about the whole security part, though. I eventually wanted to upgrade it to a more safer solution once I earn some money through the game I published.\n\rMultiplayerLogin\r\nAfter developing for some while, I wanted to work on the graphical side of the game. At the very beginning, without any post-processing and proper lighting setup, this is how the game looked like:\n\rBefore\r\nAfter proper lighting configuration and post-processing, this is how it looked:\n\rAfter\r\n\rAfter2\r\nI know there are still a lot of major issues with the lighting and post-processing configs. Especially the vignette that\u0026rsquo;s so extreme. Anti-aliasing on the text \u0026ldquo;Fall Damage\u0026rdquo; as well as on the trees can be improved significantly. NOTE: Following screenshots and video is taken BEFORE the graphics update.\nOne feature I made that I was proud of was real-time scope. In case you don\u0026rsquo;t know what this is, here\u0026rsquo;s how it looks like:\n\rRealTimeScope\r\nUnlike traditional UI overlay scope, this real-time scope must be done by having two separate cameras, one drawing the scope (lower FOV) while the other drawing the regular view. Because there have to be two cameras rendering the scene, the performance cost was a bit extreme. I also added some post-processing effects to make the effect look more dramatic.\nHere\u0026rsquo;s a youtube video I made on NANO Engine channel (my old channel) to demonstrate the game better. There has been a lot of updates after the update, though (things like graphics update, launcher update, which I\u0026rsquo;ll discuss later.). P \r\r(Yes the game was still called project color wars.)\nAs you might notice in the video, UI looks very odd and doesn\u0026rsquo;t fit the game. This is something that I started taking more seriously after discontinuing this game. I also featured recoil in the showcase video. However, because I never tried making a recoil system before, the recoil system that I used for this game was hard-coded. Meaning it wasn\u0026rsquo;t dynamic and written in a clean code at all. It might\u0026rsquo;ve looked good on the outside, but if I want to make any changes/minor adjustments to the recoil pattern, I would have to re-write the entire code again.\nHere are some more gameplay screenshots:\n\rGameplay\r \rGameplay2\r\nOther than that, I also made a launcher for this game. Game launcher checks for the latest update and updates the game if a newer version is available. It also prevented players to play with the older version. This was required to fix critical exploits that ruin the multiplayer experience. Game launcher checks for the latest update by accessing the publicly available text document which stores the latest version data. This text document is stored on a cloud hosting service, in my case, I used one drive. I originally wanted to go with google drive, but google drive didn\u0026rsquo;t work out as I couldn\u0026rsquo;t get the direct link to the file. The launcher then compares the fetched version code with the version code of the game. If they\u0026rsquo;re different in any way, it updates the game by fetching the newest version of the game, which is also hosted on a publicly available cloud storage service. Although this might sound like an optimal solution, there\u0026rsquo;s a problem. It is technically possible to decompile the game and manually change the version code of the game to match the latest version code. This allows the user to avoid the update.\n\rlauncher\r\n","date":"2017-08-10T00:00:00Z","image":"https://semikoder.github.io/p/awaken-sentinel/graphicsupdate_hu64b50e11776c16104a4e03122afb619f_1350265_120x120_fill_box_smart1_3.PNG","permalink":"https://semikoder.github.io/p/awaken-sentinel/","title":"Awaken Sentinel"}]